# All the requeried imports and libraries.
from concurrent.futures import ProcessPoolExecutor
from lxml import etree
import pickle
import numpy
import neat
import os


# This class manipulates CPPNs and generates the files associated to them.
class DesignEngine:

    MAPPING_REFERENCE = 0.5
    NO_VOXEL_CHARACTER = "0"
    PASSIVE_VOXEL_CHARACTER = "1"
    CONTRACTILE_VOXEL_CHARACTER = "3"

    X_VOXELS = "X_Voxels"
    Y_VOXELS = "Y_Voxels"
    Z_VOXELS = "Z_Voxels"

    BASE_FILE_PATH = "morphology_base.vxa"
    MORPHOLOGIES_PATH = "morphologies/morphology_"
    NUMBER_OF_WORKERS = 5

    def __init__(self, parameters_data):

        self.dimensions_3d_layout = parameters_data.get("dimensions_3d_layout")

        self.x_vector = None
        self.y_vector = None
        self.z_vector = None

        self.__initialise_layout(parameters_data)

    # This method builds CPPNs using the neat-python library.
    def build_morphologies_using_cppns(self, genomes, configuration):

        list_of_cppns = []
        morphology_counter = 0

        for genome_id, genome in genomes:

            os.makedirs(self.MORPHOLOGIES_PATH + str(morphology_counter), exist_ok=True)

            #For each CPPN, a file containing its topology is saved.
            with open(self.MORPHOLOGIES_PATH + str(morphology_counter) + "/neurons_and_connections.txt", "w") as file:

                print("{!s}".format(genome), file=file)
                print("%s nodes with %s connections." % (genome.size()[0], genome.size()[1]), file=file)
                file.close()

            cppn = neat.nn.FeedForwardNetwork.create(genome, configuration)

            # Each CPPN, is saved in a file.
            with open(self.MORPHOLOGIES_PATH + str(morphology_counter) + "/cppn.pickle", "wb") as file:

                pickle.dump(cppn, file)
                file.close()

            list_of_cppns.append(cppn)
            genome.fitness = 0.0
            morphology_counter += 1

        list_of_morphologies = []

        # The morphologies are built in parallel-like fashion.
        with ProcessPoolExecutor(max_workers=self.NUMBER_OF_WORKERS) as executor:

            for morphology in executor.map(self.build_morphology, list_of_cppns, chunksize=2):

                list_of_morphologies.append(morphology)

        cppn_ids = [x for x in range(len(list_of_morphologies))]

        # The morphologies are saved (in parallel-like fashion) in a .vxa file, the format required by VoxCad,
        # the interactive version of Voxelyze.
        with ProcessPoolExecutor(max_workers=self.NUMBER_OF_WORKERS) as executor:

            executor.map(self.write_vxa_file, list_of_morphologies, cppn_ids, chunksize=2)

    # This method queries the CPPN, which is received as parameter, to design the morphology. CPPNs have three neurons
    # as inputs, representing the (x,y,z) coordinates. Furthermore, they have two neurons as outputs. The first one
    # defines the presence (or not) of a voxel. The second one, decides the type of material.
    def build_morphology(self, cppn):

        morphology = []

        for z_coordinate in self.z_vector:

            layer = ""

            for y_coordinate in self.y_vector:

                for x_coordinate in self.x_vector:

                    cppn_input = [x_coordinate, y_coordinate, z_coordinate]
                    cppn_output = cppn.activate(cppn_input)
                    voxel_presence = numpy.fabs(cppn_output[0])

                    if voxel_presence < self.MAPPING_REFERENCE:

                        layer += self.NO_VOXEL_CHARACTER

                    else:

                        material_type = numpy.fabs(cppn_output[1])

                        if material_type < self.MAPPING_REFERENCE:

                            layer += self.PASSIVE_VOXEL_CHARACTER

                        else:

                            layer += self.CONTRACTILE_VOXEL_CHARACTER

            morphology.append(layer)

        return morphology

    # This method writes the morphology generated by a CPPN in a .vxa file.
    def write_vxa_file(self, morphology, cppn_id):

        # These two lines are helpful to trace the morphologies and identifying in which folder are saved.
        # Uncomment them if need it.
        print(cppn_id)
        print(morphology)

        parser = etree.XMLParser(remove_blank_text=True)
        raw_tree = etree.parse(self.BASE_FILE_PATH, parser=parser)
        root = raw_tree.getroot()
        root.find("VXC").find("Structure").find(self.X_VOXELS).text = str(self.dimensions_3d_layout.get("x"))
        root.find("VXC").find("Structure").find(self.Y_VOXELS).text = str(self.dimensions_3d_layout.get("y"))
        root.find("VXC").find("Structure").find(self.Z_VOXELS).text = str(self.dimensions_3d_layout.get("z"))
        root.find("Simulator").find("GA").find("FitnessFileName").text = "fitness.xml"

        for child in root.find("VXC").find("Structure").find("Data"):

            root.find("VXC").find("Structure").find("Data").remove(child)

        for layer in morphology:

            l = etree.SubElement(root.find("VXC").find("Structure").find("Data"), "Layer")
            l.text = etree.CDATA(layer)

        with open(self.MORPHOLOGIES_PATH + str(cppn_id) + "/morphology.vxa", 'wb') as f:

             raw_tree.write(f, encoding="ISO-8859-1", pretty_print=True)

    # This auxiliar method initialises the vectors that are useful for building morphologies.
    def __initialise_layout(self, parameters_data):

        self.x_vector = [float(x) for x in range(0, parameters_data.get("dimensions_3d_layout").get("x"))]
        self.y_vector = [float(y) for y in range(0, parameters_data.get("dimensions_3d_layout").get("y"))]
        self.z_vector = [float(z) for z in range(0, parameters_data.get("dimensions_3d_layout").get("z"))]
